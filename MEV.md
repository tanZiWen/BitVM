1. 按照GAS的高低排序。
2. FIFO, 按照用户发交易的时间，结合vdf。问题：用户为了抢占交易如果发起交易会一直发交易，导致链需要存储大量的交易

## 设计基于交易时间顺序的 DAG 内存池（DAGPool）
### 1. 设计目标
1. 公平性：确保交易按提交时间（时间戳）排序，防止验证者通过 MEV 攻击（如前置交易、重新排序）操纵交易顺序。
2. 有序性：利用 DAG 结构的拓扑排序，维护交易的因果顺序，反映时间戳的优先级。
3. 可扩展性：支持高吞吐量交易处理，适应大规模网络。
4. 抗 MEV 攻击：减少验证者通过重新排序或选择性包含交易获利的机会。
5. 低延迟：确保交易快速进入内存池并被处理。

### 2. 核心设计组件
#### 2.1 交易时间戳机制
1. 时间戳分配：每笔交易在客户端生成时，附带一个可信时间戳，由客户端或可信时间源（如分布式时间服务器）提供。
2. 为防止伪造时间戳，可采用以下方法：分布式时间协议：节点运行类似 NTP（网络时间协议）或区块链专用的时间共识协议（如 Algorand 的时间戳机制），确保时间戳偏差在可接受范围内（例如 ±1 秒）。
3. 加密签名：客户端对交易和时间戳进行签名，防止篡改。
4. 节点验证：接收交易的节点检查时间戳是否合理（例如，不早于最近区块时间，不晚于当前时间）。
5. 时间戳冲突处理：如果多笔交易时间戳相同，按次级排序规则（如交易哈希或 Gas 价格）决定顺序。
6. 记录交易的接收时间（节点收到交易的时间）作为备用排序依据。

#### 2.2 DAG 内存池结构
DAG 结构：
DAGPool 是一个有向无环图，其中每个节点表示一笔交易，边表示交易间的因果依赖关系（例如，交易 A 引用交易 B，则 A → B）。

1. 交易按时间戳插入 DAG，较早的交易位于 DAG 的较低层（更靠近根节点）。
2. 交易插入规则：新交易引用至少一笔已存在于 DAGPool 中的交易（类似 IOTA 的 Tangle 机制），确保因果关系。
3. 交易的插入位置由时间戳决定：新交易只能引用时间戳早于或等于其自身的交易。
4. 为防止恶意引用，验证节点检查引用的合法性（例如，引用的交易必须存在且时间戳合理）。
5. 拓扑排序：DAGPool 定期或按需执行拓扑排序，生成一个线性交易序列，优先级基于时间戳。
6. 排序算法（如深度优先搜索或 Kahn 算法）确保较早的交易优先于较晚的交易。

#### 2.3 公平排序算法
1. 时间戳优先排序：交易按时间戳升序排列，时间戳较早的交易优先进入区块或共识。如果时间戳相同，采用次级排序规则（如交易哈希的字典序）。
2. 因果依赖保护：如果交易 A 依赖交易 B（例如，A 引用 B），则即使 B 的时间戳稍晚，B 必须在 A 之前处理。通过 DAG 的边记录依赖关系，确保排序尊重因果顺序。
3. 抗操纵机制：隐藏交易内容：交易数据在进入 DAGPool 前加密，仅暴露时间戳和引用关系，防止验证者分析交易内容以进行 MEV 攻击。
4. 延迟交易可见性：交易在传播到网络前，延迟一定时间（例如 100 毫秒）公开完整内容，减少前置交易机会。

#### 2.4 共识与区块生成
1. 交易选择：验证者从 DAGPool 中按时间戳排序选择交易，生成区块或直接确认（在无区块的 DAG 协议中）。
2. 为防止验证者忽略早期交易，引入强制包含规则：必须包含时间戳早于某个阈值（例如当前时间 - 5 秒）的所有交易。
3. MEV 缓解：随机化验证者：通过 VRF（可验证随机函数）随机选择区块生产者，降低验证者操纵交易顺序的能力。
4. 分离排序与共识：交易排序由 DAGPool 自动完成，验证者仅负责打包，减少 MEV 机会。
5. 区块确认：区块（或 DAG 确认）需包含时间戳排序证明，供其他节点验证。节点可通过检查时间戳和 DAG 拓扑，检测是否存在违反时间顺序的行为。

## 什么是 VDF（可验证延迟函数）？
VDF（Verifiable Delay Function，可验证延迟函数） 是一种密码学工具，设计用于生成一个输出，需要固定的、最小计算时间（延迟），且该输出可以被快速验证。VDF 的核心目标是确保计算过程不可加速（即使使用大量并行计算资源），从而提供时间公平性。
1.1 VDF 的核心特性
1. 延迟性：计算 VDF 需要预定的时间（例如几秒到几分钟），无法通过并行计算显著加速。
2. 可验证性：验证输出的正确性很快（通常毫秒级），任何人都可以使用公开信息验证。
3. 唯一性：给定输入和延迟参数，只能生成唯一的有效输出。
4. 顺序性：计算必须按顺序执行，例如基于序列平方或模运算。

### 如果用户篡改本地时间怎么办？
在 DAGPool 的交易时间顺序设计中，用户可能尝试通过篡改本地时间伪造较早的交易时间戳，以优先处理其交易（例如，抢占 DeFi 交易机会）。VDF 的延迟特性可以帮助缓解这一问题，但需要结合其他机制确保时间戳的公平性。以下是问题的分析和应对方法：
问题分析：
1. 用户行为：用户将本地设备时间设置为较早的时间（例如，当前时间 2025-04-27 10:00:00，用户篡改为 2025-04-27 09:00:00），生成带有伪造时间戳的交易。
2. 目标：伪造时间戳使交易在 DAGPool 中获得更高的优先级（按时间戳排序）。
3. 挑战：本地时间篡改难以直接检测，因为交易时间戳由客户端生成。

如果仅依赖 VDF 的时间阈值，用户可能仍尝试在阈值范围内伪造时间戳。

### 使用 VDF 生成动态时间阈值
1. 设计：网络定期（例如每 10 秒）运行 VDF，生成一个时间戳阈值 threshold，作为交易时间戳的最早允许值。
2. VDF 输入：当前 DAGPool 状态哈希（确保阈值与网络状态绑定）。
3. VDF 延迟：例如 2 秒，确保阈值生成需要时间。
4. 交易时间戳必须满足：tx_timestamp >= threshold。

## 场景
1. 时间：2025年4月27日，10:00:00。
2. 网络：DAGPool 网络，100 个验证者节点，交易按时间戳排序。
3. 用户：Alice：诚实用户，提交 DeFi 交易 T101，使用普通手机。
4. Bob：恶意用户，试图伪造早时间戳抢占交易，使用高性能电脑。
5. 设定：共识节点每 10 秒生成 VDF 阈值，VDF 计算耗时 2 秒。
6. 当前阈值（上一轮）= 10:00:01.5，有效期到 10:00:22。
7. 网络时间（中位时间戳）≈ 10:00:03，容忍 ±2 秒偏差。
8. 交易传播延迟：平均 1-2 秒。

### 步骤 1：共识节点生成 VDF 阈值
1. 时间：10:00:02，新一轮阈值生成。
2. 验证者选择：使用 VRF 随机选择，节点 #17 被选中（公平且不可预测）。
3. VDF 计算：节点 #17 获取 DAGPool 状态快照：过去 10 秒的交易 T91-T100，计算输入 x = hash(T91-T100)。
4. 运行 VDF（2 秒，10:00:02 到 10:00:04），生成 (y, π)。
5. 计算阈值：网络时间 10:00:04 - (y % 1000) / 1000 = 10:00:03.7。
6. 广播与验证：节点 #17 广播 (threshold = 10:00:03.7, x, y, π)。
7. 其他节点（#1, #2, ..., #100）验证：VDF 正确性：VDF_Verify(x, y, π, T) 通过。
8. 输入合理性：x 包含 T91-T100（或子集 T91-T99），通过。
9. 阈值合理性：10:00:03.7 ≈ 10:00:04（±2 秒），通过。
10. 结果：90% 节点接受阈值 10:00:03.7，有效期到 10:00:24。

### 步骤 2：Alice 提交交易
1. 时间：10:00:05。
2. Alice 生成交易 T101（购买代币）：时间戳：10:00:05（手机时间，与网络同步，偏差 ±0.1 秒）。
3. DAG 引用：T98, T99（近期交易）。签名：确保交易完整性。格式：T101 = {payload: "buy token", timestamp: 10:00:05, references: [T98, T99], signature}。
4. 提交：Alice 无需计算 VDF，直接提交 T101。
5. 交易传播 1.5 秒，10:00:06.5 被节点 #1 接收。
6. 验证：节点 #1 检查：阈值：10:00:05 >= 10:00:03.7，通过。
7. 网络时间：|10:00:05 - 10:00:06.5| = 1.5 秒 < 2 秒，通过。
8. 接收时间：10:00:06.5，10:00:05 >= 10:00:06.5 - 2 = 10:00:04.5，通过。
9. 引用：T98, T99 存在，通过。
10. 结果：T101 插入 DAGPool，等待排序。

### 步骤 3：Bob 伪造交易
1. 时间：10:00:05。
2. Bob 生成交易 T102（抢购同一代币）：篡改本地时间，设置时间戳 10:00:03（早 2 秒）。
3. DAG 引用：T98, T99。格式：T102 = {payload: "buy token", timestamp: 10:00:03, references: [T98, T99], signature}。
4. 提交：Bob 无需计算 VDF，直接提交 T102。
5. 交易传播 1 秒（Bob 靠近节点 #2），10:00:06 被节点 #2 接收。
6. 验证：节点 #2 检查：阈值：10:00:03 < 10:00:03.7，失败。
7. 网络时间：|10:00:03 - 10:00:06| = 3 秒 > 2 秒，失败。
8. 接收时间：10:00:06，10:00:03 < 10:00:06 - 2 = 10:00:04，失败。
9. 结果：T102 被拒绝



    













