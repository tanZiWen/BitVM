比特币能用版本：

1. 代码仓库：https://github.com/bitcoin/bitcoin 语言：C++
提供完整的比特币协议实现（P2P网络、区块链、共识规则等）。
2.  代码仓库：https://github.com/paritytech/parity-bitcoin 语言：rust
很久没有维护，parity公司，Gavin Wood
3. 代码仓库：https://github.com/rust-bitcoin/rust-bitcoin 语言：rust
社区一直在维护，代码不全，使用最广泛的代码。 https://github.com/libp2p/rust-libp2p
4. 代码仓库：https://github.com/btcsuite/btcd  语言：golang
代码比较完备，社区一直在维护
5. 代码仓库：https://github.com/cloudhead/nakamoto  带隐私，start较少


1. 交易结构体定义  问题：手续费收取？ UTXO验证？
2. 区块定义
3. 同步节点交易验证
4. 区块验证
5. 序列化反序列化

#### 交易结构体定义
```rust
use serde::{Serialize, Deserialize};
use bitcoin::hashes::sha256d::Hash as Txid;
use bitcoin::Amount;

// 版本号，保持与比特币兼容
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct Version {
    pub version: u32, // 交易版本号
}

// 交易结构体
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct Transaction {
    pub version: Version,
    pub input: Vec<TxIn>,
    pub output: Vec<TxOut>,
    pub locktime: u32, // 保留locktime以支持时间锁
    pub payload: Vec<u8>, //L0数据, 1M
}

// 交易输入
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct TxIn {
    pub previous_output: OutPoint,
    pub zk_proof: Vec<u8>, // 零知识证明，验证UTXO未花费及权限，200KB
    pub sequence: u32,     // 保留sequence以支持RBF等功能
}

// 交易输出
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct TxOut {
    pub value: Amount,     // 金额（以聪为单位）
    pub vk: Vec<u8>, // 验证密钥，用于验证后续zk_proof
}

// 前一交易输出引用
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct OutPoint {
    pub txid: Txid, // 前一交易哈希
    pub vout: u32,  // 输出索引
}
```

#### 手续费

```rust
// 计算公式
手续费 = Σ(TxIn.value) - Σ(TxOut.value)

// 每字节手续费
fee_per_byte = fee / serialized_size

// 设置一个最低的费率
min_per_fee = 10 sat

// 交易大小验证
pub fn validate_size(&self) -> Result<(), Error> {
    const MAX_PAYLOAD_SIZE: usize = 1_000_000; // 1 MB
    const MAX_ZK_PROOF_SIZE: usize = 200_000; // 200 KB
    if self.payload.len() > MAX_PAYLOAD_SIZE {
        return Err(Error::PayloadTooLarge);
    }
    if self.input.iter().any(|txin| txin.zk_proof.len() > MAX_ZK_PROOF_SIZE) {
        return Err(Error::ZkProofTooLarge);
    }
    Ok(())
}

序列化交易
pub fn serialized_size(&self) -> usize {
    // 使用 serde 序列化计算大小（假设使用二进制编码）
    bincode::serialize(self).map(|bytes| bytes.len()).unwrap_or(0)
}

// 计算手续费

pub fn calculate_fee(&self, utxo_set: &UtxoSet) -> Result<Amount, Error> {
    let input_sum: Amount = self.input.iter()
        .map(|txin| utxo_set.get_utxo(&txin.previous_output).map(|utxo| utxo.value))
        .sum::<Result<Amount, _>>()?;
    let output_sum: Amount = self.output.iter().map(|txout| txout.value).sum();
    if input_sum < output_sum {
        return Err(Error::InsufficientInput);
    }
    Ok(input_sum - output_sum)
}


// 每个字节费率
pub fn fee_per_byte(&self, utxo_set: &UtxoSet) -> Result<f64, Error> {
    let fee = self.calculate_fee(utxo_set)?.to_sat();
    let size = self.serialized_size();
    if size == 0 {
        return Err(Error::InvalidSize);
    }
    Ok(fee as f64 / size as f64) // 返回聪/字节
}

```
